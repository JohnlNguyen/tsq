newbintree <- function(){
tree <- new.env(parent=globalenv())
tree$vals <- matrix(cbind(NA,NA,NA),nrow=1,ncol=3, dimnames = list(c(NULL),
c("Value","Left", "Right")) )
colnames(tree, do.NULL = FALSE)
class(tree) <- append(class(tree),"bintree")
return(tree)
}
push <- function(obj, val) UseMethod("push")
pop <- function(obj) UseMethod("pop")
# val <- graph[root,1]
# left <- graph[root,2]
# right <- graph[root,3]
# root <- the row of the node
helper <- function(root, inVal ,graph){
if(inVal < graph[root,1] & is.na(graph[root,2])){ #BASE CASE
graph <- rbind(graph,c(inVal,NA,NA))
graph[root,2] <- nrow(graph)
return(graph)
}
if(inVal > graph[root,1] & is.na(graph[root,3])){ #BASE CASE
graph <- rbind(graph,c(inVal,NA,NA))
graph[root,3] <- nrow(graph)
return(graph)
}
if(inVal < graph[root,1]) helper(graph[root,2],inVal,graph)
else helper(graph[root,3],inVal,graph)
}
push.bintree <- function(obj,val) {
if(nrow(obj$vals) == 1){ # Empty Tree
obj$vals <- rbind(obj$vals,c(val,NA,NA))
}
else obj$vals <- helper(2,val,obj$vals)
return(obj$vals)
}
pop.bintree <- function(obj) {
if(nrow(obj$vals) == 1){ # Empty Tree
stop("Error: attempt to pop empty tree")
}
else val <- pop_helper(2,obj$vals)
return(val)
}
pop_helper <- function(root, graph){
if(!is.na(graph[root,1]) & is.na(graph[root,2]) & is.na(graph[root,3])) { # BASE CASE
val <- graph[root,1]
graph <- graph[-root,]
return(val)
}
else pop_helper(graph[root,2], graph)
}
print.bintree <- function(tree) {
obj <- tree$vals
printhelper <- function(obj, row) {
if(!is.na(obj[as.numeric(row),2])) {
printhelper(obj,obj[as.numeric(row),2])
}
print(obj[as.numeric(row),1])
if(!is.na(obj[as.numeric(row),3])) {
printhelper(obj,obj[as.numeric(row),3])
}
}
if(nrow(obj) > 1) printhelper(obj,2)
}
######## TEST CASE #################
tree <- newbintree()
push(tree,7)
push(tree,5)
push(tree,6)
pop(tree)
push(tree,9)
newbintree <- function(){
tree <- new.env(parent=globalenv())
tree$vals <- matrix(cbind(NA,NA,NA),nrow=1,ncol=3, dimnames = list(c(NULL),
c("Value","Left", "Right")) )
colnames(tree, do.NULL = FALSE)
class(tree) <- append(class(tree),"bintree")
return(tree)
}
push <- function(obj, val) UseMethod("push")
pop <- function(obj) UseMethod("pop")
# val <- graph[root,1]
# left <- graph[root,2]
# right <- graph[root,3]
# root <- the row of the node
helper <- function(root, inVal ,graph){
if(inVal < graph[root,1] & is.na(graph[root,2])){ #BASE CASE
graph <- rbind(graph,c(inVal,NA,NA))
graph[root,2] <- nrow(graph)
return(graph)
}
if(inVal > graph[root,1] & is.na(graph[root,3])){ #BASE CASE
graph <- rbind(graph,c(inVal,NA,NA))
graph[root,3] <- nrow(graph)
return(graph)
}
if(inVal < graph[root,1]) helper(graph[root,2],inVal,graph)
else helper(graph[root,3],inVal,graph)
}
push.bintree <- function(obj,val) {
if(nrow(obj$vals) == 1){ # Empty Tree
obj$vals <- rbind(obj$vals,c(val,NA,NA))
}
else obj$vals <- helper(2,val,obj$vals)
return(obj$vals)
}
pop.bintree <- function(obj) {
if(nrow(obj$vals) == 1){ # Empty Tree
stop("Error: attempt to pop empty tree")
}
else val <- pop_helper(2,obj$vals)
return(val)
}
pop_helper <- function(root, graph){
if(!is.na(graph[root,1]) & is.na(graph[root,2]) & is.na(graph[root,3])) { # BASE CASE
val <- graph[root,1]
graph <- graph[-root,]
return(val)
}
if(!is.na(graph[root,1]) & is.na(graph[root,2]) & !is.na(graph[root,3])) { # BASE CASE
val <- graph[root,1]
graph <- graph[-root,]
return(val)
}
else pop_helper(graph[root,2], graph)
}
print.bintree <- function(tree) {
obj <- tree$vals
printhelper <- function(obj, row) {
if(!is.na(obj[as.numeric(row),2])) {
printhelper(obj,obj[as.numeric(row),2])
}
print(obj[as.numeric(row),1])
if(!is.na(obj[as.numeric(row),3])) {
printhelper(obj,obj[as.numeric(row),3])
}
}
if(nrow(obj) > 1) printhelper(obj,2)
}
######## TEST CASE #################
tree <- newbintree()
push(tree,7)
push(tree,5)
push(tree,6)
pop(tree)
push(tree,9)
newbintree <- function(){
tree <- new.env(parent=globalenv())
tree$vals <- matrix(cbind(NA,NA,NA),nrow=1,ncol=3, dimnames = list(c(NULL),
c("Value","Left", "Right")) )
colnames(tree, do.NULL = FALSE)
class(tree) <- append(class(tree),"bintree")
return(tree)
}
push <- function(obj, val) UseMethod("push")
pop <- function(obj) UseMethod("pop")
# val <- graph[root,1]
# left <- graph[root,2]
# right <- graph[root,3]
# root <- the row of the node
helper <- function(root, inVal ,graph){
if(inVal < graph[root,1] & is.na(graph[root,2])){ #BASE CASE
graph <- rbind(graph,c(inVal,NA,NA))
graph[root,2] <- nrow(graph)
return(graph)
}
if(inVal > graph[root,1] & is.na(graph[root,3])){ #BASE CASE
graph <- rbind(graph,c(inVal,NA,NA))
graph[root,3] <- nrow(graph)
return(graph)
}
if(inVal < graph[root,1]) helper(graph[root,2],inVal,graph)
else helper(graph[root,3],inVal,graph)
}
push.bintree <- function(obj,val) {
if(nrow(obj$vals) == 1){ # Empty Tree
obj$vals <- rbind(obj$vals,c(val,NA,NA))
}
else obj$vals <- helper(2,val,obj$vals)
return(obj$vals)
}
pop.bintree <- function(obj) {
if(nrow(obj$vals) == 1){ # Empty Tree
stop("Error: attempt to pop empty tree")
}
else obj$vals <- pop_helper(2,obj$vals)
return(obj$vals)
}
pop_helper <- function(root, graph){
if(!is.na(graph[root,1]) & is.na(graph[root,2]) & is.na(graph[root,3])) { # BASE CASE
val <- graph[root,1]
graph <- graph[-root,]
return(val)
}
if(!is.na(graph[root,1]) & is.na(graph[root,2]) & !is.na(graph[root,3])) { # BASE CASE
val <- graph[root,1]
graph <- graph[-root,]
return(val)
}
else pop_helper(graph[root,2], graph)
}
print.bintree <- function(tree) {
obj <- tree$vals
printhelper <- function(obj, row) {
if(!is.na(obj[as.numeric(row),2])) {
printhelper(obj,obj[as.numeric(row),2])
}
print(obj[as.numeric(row),1])
if(!is.na(obj[as.numeric(row),3])) {
printhelper(obj,obj[as.numeric(row),3])
}
}
if(nrow(obj) > 1) printhelper(obj,2)
}
######## TEST CASE #################
tree <- newbintree()
push(tree,7)
push(tree,5)
push(tree,6)
pop(tree)
push(tree,9)
newbintree <- function(){
tree <- new.env(parent=globalenv())
tree$vals <- matrix(cbind(NA,NA,NA),nrow=1,ncol=3, dimnames = list(c(NULL),
c("Value","Left", "Right")) )
colnames(tree, do.NULL = FALSE)
class(tree) <- append(class(tree),"bintree")
return(tree)
}
push <- function(obj, val) UseMethod("push")
pop <- function(obj) UseMethod("pop")
# val <- graph[root,1]
# left <- graph[root,2]
# right <- graph[root,3]
# root <- the row of the node
helper <- function(root, inVal ,graph){
if(inVal < graph[root,1] & is.na(graph[root,2])){ #BASE CASE
graph <- rbind(graph,c(inVal,NA,NA))
graph[root,2] <- nrow(graph)
return(graph)
}
if(inVal > graph[root,1] & is.na(graph[root,3])){ #BASE CASE
graph <- rbind(graph,c(inVal,NA,NA))
graph[root,3] <- nrow(graph)
return(graph)
}
if(inVal < graph[root,1]) helper(graph[root,2],inVal,graph)
else helper(graph[root,3],inVal,graph)
}
push.bintree <- function(obj,val) {
if(nrow(obj$vals) == 1){ # Empty Tree
obj$vals <- rbind(obj$vals,c(val,NA,NA))
}
else obj$vals <- helper(2,val,obj$vals)
return(obj$vals)
}
pop.bintree <- function(obj) {
if(nrow(obj$vals) == 1){ # Empty Tree
stop("Error: attempt to pop empty tree")
}
else val <- pop_helper(2,obj$vals)
return(val)
}
pop_helper <- function(root, graph){
if(!is.na(graph[root,1]) & is.na(graph[root,2]) & is.na(graph[root,3])) { # BASE CASE
val <- graph[root,1]
graph <- graph[-root,]
return(val)
}
if(!is.na(graph[root,1]) & is.na(graph[root,2]) & !is.na(graph[root,3])) { # BASE CASE
val <- graph[root,1]
graph <- graph[-root,]
return(val)
}
else pop_helper(graph[root,2], graph)
}
print.bintree <- function(tree) {
obj <- tree$vals
printhelper <- function(obj, row) {
if(!is.na(obj[as.numeric(row),2])) {
printhelper(obj,obj[as.numeric(row),2])
}
print(obj[as.numeric(row),1])
if(!is.na(obj[as.numeric(row),3])) {
printhelper(obj,obj[as.numeric(row),3])
}
}
if(nrow(obj) > 1) printhelper(obj,2)
}
######## TEST CASE #################
tree <- newbintree()
push(tree,7)
push(tree,5)
push(tree,6)
pop(tree)
push(tree,9)
push(tree,4)
push(tree,1)
push(tree,30)
push(tree,8)
push(tree,10)
stack <- function() {
st <- new.env(parent=globalenv())
st$data <- c(NA)
class(st) <- append(class(st), "stack")
return(st)
}
push <- function(obj, val) UseMethod("push")
pop <- function(obj, val) UseMethod("pop")
push.stack <- function(obj,val) {
if(is.na(val)) stop("Invalid type")
obj$data <- c(obj$data,val)
}
pop.stack <- function(obj) {
if(length(obj$data) == 1)
stop("Stack is empty")
end <- length(obj$data)
top <- obj$data[end]
obj$data <- obj$data[-end]
return(top)
}
print.stack <- function(obj){
if(length(obj$data) == 1) return()
print(obj$data[-1])
}
source('stack.R')
s <- stack()
push(s,5)
print(s)
push(s,6)
push(s,7)
print(s)
push(s,"hello")
push(s,"%%")
print(s)
pop(s)
pop(s)
print(s)
newqueue <- function() {
q <- new.env(parent=globalenv())
q$data <- c(NA)
class(q) <- append(class(q), "queue")
return(q)
}
push <- function(obj, val) UseMethod("push")
pop <- function(obj, val) UseMethod("pop")
push.queue <- function(obj,val) {
if(is.na(val)) stop("Invalid type")
obj$data <- c(obj$data,val)
}
pop.queue <- function(obj) {
if(length(obj$data) == 1)
stop("Queue is empty")
front <- obj$data[2]
obj$data <- obj$data[-2]
return(front)
}
print.queue <- function(obj){
if(length(obj$data) == 1) return()
print(obj$data[-1])
}
source('queue.R')
q <- newqueue()
push(q,5)
push(q,6)
push(q,7)
print(q)
push(q,"hi there")
push(q,"uhhh cani help you")
push(q,"241$^@!hello$@")
print(q)
pop(q)
print(q)
pop(q)
print(q)
pop(q)
print(q)
pop(q)
print(q)
pop(q)
print(q)
pop(q)
print(q)
pop(q)
pop(q)
pop(q)
pop(q)
?
exit
??exit
